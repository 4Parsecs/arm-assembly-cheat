= ARM Assembly Cheat
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

ARMv7 and ARMv8 assembly userland minimal examples tutorial. Runnable asserts on x86 host with QEMU user mode. Nice GDB step debug setup. Tested on Ubuntu 18.04 host.

toc::[]

== Getting started

Ubuntu 16.04 amd64:

....
./configure
....

Build all examples:

....
make
....

Build and run a single ARMv7 example on QEMU user mode:

....
make test-<basename-no-extension>
....

E.g.:

....
make test-hello_driver
....

will run:

....
hello_driver.S
....

Build and run all tests in current and child directories:

....
make test
....

<<armv8>> examples are all located under the link:v8/[] directory. They can be run in the same way as ARMv7 examples:

....
cd v8
make test-mov
....

Alternatively, to help with tab complete, the following all do the same thing:

....
./t hello_driver
./t hello_driver.
./t hello_driver.out
....

Almost all example don't output anything, they just assert that the computations are as expected and exit 0 is that was the case.

Try messing with the examples to see them fail, e.g. link:fail.S[]. You should see something like:

....
error 1 at line 7
TEST FAILED: fail.out
Makefile:78: recipe for target 'test' failed
make: *** [test] Error 1
....

So look how nice we are: we even gave you the line number of the failing assert!

Test that all examples exit with status 0:

....
make test
....

=== GDB step debug

Debug one example with GDB:

....
make gdb-add
....

Shortcut:

....
./t -g add
....

This leaves us right at the end of `asm_main`, and at the start of the assembly code in the `.S` file.

It is not possible to restart the running program from GDB as in `gdbserver --multi` unfortunately: https://stackoverflow.com/questions/51357124/how-to-restart-qemu-user-mode-programs-from-the-gdb-stub-as-in-gdbserver-multi

Bibliography: https://stackoverflow.com/questions/20590155/how-to-single-step-arm-assembler-in-gdb-on-qemu/51310791#51310791

=== Disassemble

Even though <<gdb-step-debug>> can already disassemble instructions for us, it is sometimes useful to have the disassembly in a text file for further examination.

Disassemble all examples:

....
make -j `nproc` objdump
....

Disassemble one example:

....
make add.objdump
....

Examine one disassembly:

....
less -p asm_main add.objdump
....

This jumps directly to `asm_main`, which is what you likely want to see.

Disassembly is still useful even though we are writing assembly because the assembler can do some non-obvious magic that we want to understand.

=== Get rid of distro packages

If you are like me, and you don't trust distro blobs, or if your distro does not provide working blobs, here goes a working procedure to replace the following distro blobs:

* crosstool-ng: https://stackoverflow.com/revisions/51310756/6
* qemu:
+
....
git clone --recursive git://git.qemu.org/qemu.git
cd qemu
git checkout v2.12.0
./configure --target-list=arm-linux-user
make -j`nproc`
....

Then build and run with:

....
make \
  CTNG=crosstool-ng/.build/ct_prefix \
  PREFIX=arm-cortex_a15-linux-gnueabihf \
  QEMU_EXE=arm-linux-user/qemu-arm \
  test \
;
....

Ideally we should just add submodules here and automate from there, but I've done that like 5 times this month and I'm lazy now.

== About

`qemu-arm-static` is used for emulation on x86 hosts. It translates ARM to x86, and forwards system calls to the host kernel.

OS portability is achieved with the C standard library which makes system calls for us.

Non OS portable examples will be clearly labeled with their OS, e.g.: <<linux-system-calls>>.

These examples show how our insfrastructure works:

* link:fail.S[]
* link:hello_driver.S[]
* link:hello_common.S[]

=== C driver

We link all examples agains a C program: link:main.c[]. Sample simplified commands:

....
arm-linux-gnueabihf-gcc -c -o 'main.o' 'main.c'
arm-linux-gnueabihf-gcc -c -o 'sub.o' 'sub.S'
arm-linux-gnueabihf-gcc -o 'sub.out' 'sub.o' main.o
....

The C driver then just calls `asm_main`, which each `.S` example implements.

This allows us to easily use the C standard libray portably: from the point of view of GCC, everything looks like a regular C program, which does the required glibc initialization before `main()`.

=== Build documentation

....
make doc
xdg-open README.html
....

== Registers

Examples: link:regs.S[]

Bibliography: <<armarm7>> A2.3 "ARM core registers".

== Instructions

Grouping loosely based on that of the <<armarm7>> Chapter A4 "The Instruction Sets".

=== Branch instructions

==== b

Unconditional branch.

Example: link:b.S[]

The encoding stores `pc` offsets in 24 bits. The destination must be a multiple of 4, which is easy since all instructions are 4 bytes.

This allows for 26 bit long jumps, which is 64 MiB.

TODO: what happens if we want to jump longer than that?

==== beq

Branch if equal based on the status registers.

Example: link:beq.S[].

The family of instructions includes:

* `beq`: branch if equal
* `bne`: branch if not equal
* `ble`: less or equal
* `bge`: greater or equal
* `blt`: less than
* `bgt`: greater than

==== bl

Branch with link, i.e. branch and store the return address on the `rl` register.

Example: link:bl.S[]

This is the major way to make function calls.

The current ARM / Thumb mode is encoded in the least significant bit of lr.

===== bx

`bx`: branch and switch between ARM / Thumb mode, encoded in the least significant bit of the given register.

`bx lr` is the main way to return from function calls after a `bl` call.

Since `bl` encodes the current ARM / Thumb in the register, `bx` keeps the mode unchanged by default.

==== cbz

Compare and branch if zero.

Example: link:v8/cbz.S[]

Only in ARMv8 and ARMv7 Thumb mode, not in armv7 ARM mode.

=== Load and store instructions

In ARM, there are only two instruction families that do memory access: `ldr`  to load and `str` to store.

Examples:

* link:ldr.S[]
* link:str.S[]

Everything else works on register and immediates.

This is part of the RISC-y beauty of the ARM instruction set, unlike x86 in which several operations can read from memory, and helps to predict how to optimize for a given CPU pipeline.

=== Data processing instructions

* link:add.S[]
* link:and.S[]
* link:mul.S[]
* link:sub.S[]

==== mov

Move an immediate to a register, or a register to another register.

Cannot load from or to memory, since only the `ldr` and `str` instruction families can do that in ARM: <<load-and-store-instructions>>

Example: link:mov.S[]

Since every instruction <<instruction-length,has a fixed 4 byte size>>, there is not enough space to encode arbitrary 32-bit immediates in a single instruction, since some of the bits are needed to actually encode the instruction itself.

The solutions to this problem are mentioned at:

* https://stackoverflow.com/questions/38689886/loading-32-bit-values-to-a-register-in-arm-assembly
* https://community.arm.com/processors/b/blog/posts/how-to-load-constants-in-assembly-for-arm-architecture

Summary of solutions:

* `movw` and `movt`
* place it in memory. But then how to load the address, which is also a 32-bit value?
** use pc-relative addressing if the memory is close enough
** use `orr` encodable shifted immediates

The blog article summarizes nicely which immediates can be encoded and the design rationale:

____
An Operand 2 immediate must obey the following rule to fit in the instruction: an 8-bit value rotated right by an even number of bits between 0 and 30 (inclusive). This allows for constants such as 0xFF (0xFF rotated right by 0), 0xFF00 (0xFF rotated right by 24) or 0xF000000F (0xFF rotated right by 4).

In software - especially in languages like C - constants tend to be small. When they are not small they tend to be bit masks. Operand 2 immediates provide a reasonable compromise between constant coverage and encoding space; most common constants can be encoded directly.
____

Assemblers however support magic memory allocations which may hide what is truly going on: https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly Always ask your friendly disassembly for a good confirmation.

==== push

Push one ore more registers to the value contained in the stack.

Example: link:push.S[]

Mnemonics for:

....
STMDB sp!, reglist
LDMIA sp! reglist
....

but recommended in that case.

The registers are encoded as single bits inside the instruction: each bit represents one register.

As a consequence, the push order is fixed no matter how you write the assembly instruction: there is not enough space to encode ordering TODO example.

AArch64 loses those instructions, likely because it was not possible anymore to encode all registers: http://stackoverflow.com/questions/27941220/push-lr-and-pop-lr-in-arm-arch64 and replaces them with `stp` and `ldp`.

== Instruction encoding

=== Instruction length

Every ARMv7 instruction is 4 bytes long.

This RISC-y design likely makes processor design easier and allows for certain optimizations, at the cost of slightly more complex assembly. Totally worth it.

<<Thumb>> is an alternative encoding.

=== Thumb

Variable bit encoding where instructions are either 4 or 2 bytes.

In general cannot encode conditional instructions, but <<thumb-2>> can.

Example:

....
make test-thumb
....

Outcome: it does not blow up.

Source:

* link:driver_thumb.c[]
* link:thumb.S[]

https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings

=== Thumb-2

Newer version of thumb that allows encoding almost all instructions, TODO example.

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471i/CHDFEDDB.html

== Calling convention

Call C standard library functions from assembly:

....
make test-c_from_arm
....

Output:

....
hello puts
hello printf 12345678
....

Source: link:c_from_arm.S[]

Don't forget that stack must be 8 byte aligned.

Bibliography: http://stackoverflow.com/questions/8422287/calling-c-functions-from-arm-assembly

== Linux system calls

Do a `write` and `exit` raw Linux system calls:

....
make -C linux test
make -C v8/linux test
....

Outcome for both:

....
hello world
....

Sources:

* link:linux/hello.S[]
* link:v8/linux/hello.S[]

Unlike most our other examples, which use the C standard library for portability, this one can only be run on Linux.

The syscall numbers are defined at:

* v7: https://github.com/torvalds/linux/blob/v4.17/arch/arm/tools/syscall.tbl
* v8: https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h

Bibliography:

* https://stackoverflow.com/questions/12946958/what-is-the-interface-for-arm-system-calls-and-where-is-it-defined-in-the-linux
* https://stackoverflow.com/questions/45742869/linux-syscall-conventions-for-armv8
* https://reverseengineering.stackexchange.com/questions/16917/arm64-syscalls-table

== ARMv8

In this repository we will document only points where ARMv8 differs from ARMv7 behaviour: so you should likely learn ARMv7 first.

ARMv8 is the 64 bit version of the ARM architecture.

It has two states:

* AArch32: 32-bit legacy compatibility mode, similar to ARMv7
* AArch64: 64-bit mode, the main mode of operation

Great summary of differences from AArch32: <https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features>

Some random ones, TODO create clean examples of them:

* the stack has to 16-byte aligned. Therefore, the main way to push things to stack is `ldp` and  `stp`, which push two 8 byte registers at a time

=== ARMv8 movk

Fill a 64 bit register with 4 16-bit instructions one at a time.

Example: link:v8/movk.S[]

Bibliography: https://stackoverflow.com/questions/27938768/moving-a-32-bit-constant-in-arm-arch64-register

=== ARMv8 registers

Example: link:v8/regs.S[]

=== stp

Push a pair of registers to the stack.

TODO minimal example. Currently used on link:v8/commmon_arch.h[] since it is the main way to restore register state.

== Theory

TODO review all of those and move them into the main README. They are from a previous life.

. link:how-to-play-with-arm.md[How to play with ARM]
. link:introduction.md[Introduction]
. link:versions.md[Versions]
. link:calling-conventions.md[Calling conventions]
. link:extensions.md[Extensions]
.. link:thumb.md[Thumb]
. link:vs-x86.md[Vs x86]
. link:compilers.md[Compilers]
. link:free-implementations.md[Free implementations]
. link:gas.md[GAS]
. link:flags.md[Flags]
. link:system-programming.md[System programming]
. link:isa-documentation.md[ISA documentation]
. link:glossary.md[Glossary]

== Bibliography

ISA quick references can be found in some places however:

- <https://web.archive.org/web/20161009122630/http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf>

Getting started tutorials:

* http://www.davespace.co.uk/arm/introduction-to-arm/
* https://azeria-labs.com/writing-arm-assembly-part-1/

=== Official manuals

The official manuals were stored in http://infocenter.arm.com but as of 2017 they started to slowly move to link:https://developer.arm.com[].

Each revision of a document has a "ARM DDI" unique document identifier.

The "ARM Architecture Reference Manuals" are the official canonical ISA documentation document. In this repository, we always reference the following revisions:

Bibliography: https://www.quora.com/Where-can-I-find-the-official-documentation-of-ARM-instruction-set-architectures-ISAs

[[armarm7]]
==== ARMv7 architecture reference manual

ARMv7: https://developer.arm.com/products/architecture/a-profile/docs/ddi0406/latest/arm-architecture-reference-manual-armv7-a-and-armv7-r-edition

We use: DDI 0406C.d: https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf

[[armarm8]]
==== ARMv8 architecture reference manual

https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile

We use: ARM DDI 0487C.a: https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf

==== Programmer’s Guide for ARMv8-A

https://developer.arm.com/docs/den0024/latest/preface

A more terse human readable introduction to the ARM architecture than the reference manuals.

We use: DEN0024A https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf
