= ARM Assembly Cheat
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

ARMv7 and ARMv8 assembly userland minimal examples. Runnable asserts on x86 host with QEMU user mode. Nice GDB step debug setup. Tested on Ubuntu 18.04 host.

toc::[]

== Getting started

Ubuntu 16.04 amd64:

....
./configure
....

Build all examples:

....
make
....

Build and run a single ARMv7 example on QEMU user mode:

....
make test-<basename-no-extension>
....

E.g.:

....
make test-hello_driver
....

will run:

....
hello_driver.S
....

<<armv8>> examples are all located under the link:v8[] directory. They can be run in the same way as ARMv7 examples:

....
cd v8
make test-mov
....

Alternatively, to help with tab complete, the following all do the same thing:

....
./t hello_driver
./t hello_driver.
./t hello_driver.out
....

Almost all example don't output anything, they just assert that the computations are as expected and exit 0 is that was the case.

Try messing with the examples to see them fail, e.g. link:fail.S[]. You should see something like:

....
error 1 at line 7
TEST FAILED: fail.out
Makefile:78: recipe for target 'test' failed
make: *** [test] Error 1
....

So look how nice we are: we even gave you the line number of the failing assert!

Test that all examples exit with status 0:

....
make test
....

=== GDB step debug

Debug one example with GDB:

....
make gdb-add
....

Shortcut:

....
./t -g add
....

This leaves us right at the end of `asm_main`, and at the start of the assembly code in the `.S` file.

TODO: possible to restart the running program from GDB as in `gdbserver --multi`? Convenient as you can reuse breakpoints easily.

Bibliography: https://stackoverflow.com/questions/20590155/how-to-single-step-arm-assembler-in-gdb-on-qemu/51310791#51310791

=== Disassemble

Even though <<gdb-step-debug>> can already disassemble instructions for us, it is sometimes useful to have the disassembly in a text file for further examination.

Disassemble all examples:

....
make -j `nproc` objdump
....

Disassemble one example:

....
make add.objdump
....

Examine one disassembly:

....
less -p asm_main add.objdump
....

This jumps directly to `asm_main`, which is what you likely want to see.

Disassembly is still useful even though we are writing assembly because the assembler can do some non-obvious magic that we want to understand.

=== Get rid of distro packages

If you are like me, and you don't trust distro blobs, or if your distro does not provide working blobs, here goes a working procedure to replace the following distro blobs:

* crosstool-ng: https://stackoverflow.com/revisions/51310756/6
* qemu:
+
....
git clone --recursive git://git.qemu.org/qemu.git
cd qemu
git checkout v2.12.0
./configure --target-list=arm-linux-user
make -j`nproc`
....

Then build and run with:

....
make \
  CTNG=crosstool-ng/.build/ct_prefix \
  PREFIX=arm-cortex_a15-linux-gnueabihf \
  QEMU_EXE=arm-linux-user/qemu-arm \
  test \
;
....

Ideally we should just add submodules here and automate from there, but I've done that like 5 times this month and I'm lazy now.

== About

Top level examples target the armv7 ISA (32-bit). New AArch64 features will be put in subdirectory.

`qemu-arm-static` is used for emulation. It translates ARM to x86, and forwards system calls to the kernel.

OS portability is achieved with the C standard library which makes system calls for us.

Non OS portable examples will be clearly labeled with their OS.

== Infrastructure

These examples show how our tooling works:

. link:fail.S[]
. link:hello_driver.S[]
. link:hello_common.S[]

=== C driver

We link all examples agains a C program: link:main.c[]. Sample simplified commands:

....
arm-linux-gnueabihf-gcc -c -o 'main.o' 'main.c'
arm-linux-gnueabihf-gcc -c -o 'sub.o' 'sub.S'
arm-linux-gnueabihf-gcc -o 'sub.out' 'sub.o' main.o
....

The C driver then just calls `asm_main`, which each `.S` example implements.

This allows us to easily use the C standard libray portably: from the point of view of GCC, everything looks like a regular C program, which does the required glibc initialization before `main()`.

== Registers

Examples: link:regs.S[]

Bibliography: [[armarm7]] A2.3 "ARM core registers".

== Instructions

Grouping loosely based on that of the [[armarm7]] Chapter A4 "The Instruction Sets".

=== Branch instructions

. link:b.S[]
. link:beq.S[]
. link:bl.S[]

`B` stores PC offsets in 24 bits. The destination must be a multiple of 4, which is easy since all instructions are 4 bytes.

This allows for 26 bit long jumps, that is 64 MiB.

TODO: what happens if we want to jump longer than that?

=== Load and store instructions

In ARM, there are only two instruction families that do memory access: `ldr` and `str`:

Examples:

* link:ldr.S[]
* link:str.S[]

Everything else works on register and immediates.

This is part of the RISC-y beauty of the ARM instruction set, unlike x86 in which several operations can read from memory, and helps to predict how to optimize for a given CPU pipeline.

=== Data processing instructions

. link:add.S[]
. link:and.S[]
. link:mul.S[]
. link:sub.S[]

==== mov

Move an immediate to a register.

Example: link:mov.S[]

Since every instruction <<instruction-length,has a fixed 4 byte size>>, there is not enough space to encode arbitrary 32-bit immediates in a single instruction, since some of the bits are needed to actually encode the instruction itself.

The solutions to this problem are mentioned at:

* https://stackoverflow.com/questions/38689886/loading-32-bit-values-to-a-register-in-arm-assembly
* https://community.arm.com/processors/b/blog/posts/how-to-load-constants-in-assembly-for-arm-architecture

Summary of solutions:

* `movw` and `movt`
* place it in memory. But then how to load the address, which is also a 32-bit value?
** use pc-relative addressing if the memory is close enough
** use `orr` encodable shifted immediates

The blog article summarizes nicely which immediates can be encoded and the design rationale:

____
An Operand 2 immediate must obey the following rule to fit in the instruction: an 8-bit value rotated right by an even number of bits between 0 and 30 (inclusive). This allows for constants such as 0xFF (0xFF rotated right by 0), 0xFF00 (0xFF rotated right by 24) or 0xF000000F (0xFF rotated right by 4).

In software - especially in languages like C - constants tend to be small. When they are not small they tend to be bit masks. Operand 2 immediates provide a reasonable compromise between constant coverage and encoding space; most common constants can be encoded directly.
____

Assemblers however support magic memory allocations which may hide what is truly going on: https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly Always ask your friendly disassembly for a good confirmation.

==== push

. link:push.S[]

== Instruction encoding

=== Instruction length

Every ARMv7 instruction is 4 bytes long.

This RISC-y design likely makes processor design easier and allows for certain optimizations, at the cost of slightly more complex assembly. Totally worth it.

<<Thumb>> is an alternative encoding.

=== Thumb

Variable bit encoding where instructions are either 4 or 2 bytes.

In general cannot encode conditional instructions, but <<thumb-2>> can.

Example:

....
make test-thumb
....

Outcome: it does not blow up.

Source:

* link:driver_thumb.c[]
* link:thumb.S[]

https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings

=== Thumb-2

Newer version of thumb that allows encoding almost all instructions, TODO example.

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471i/CHDFEDDB.html

== Calling convention

Call C standard library functions from assembly:

....
make test-c_from_arm
....

Output:

....
hello puts
hello printf 12345678
....

Source: link:c_from_arm.S[]

Don't forget that stack must be 8 byte aligned.

Bibliography: http://stackoverflow.com/questions/8422287/calling-c-functions-from-arm-assembly

== Linux system calls

Do a `write` and `exit` raw Linux system calls:

....
make -C linux
....

Outcome:

....
hello world
....

Source: link:linux/hello.S[].

Unlike most our other examples, which use the C standard library for portability, this one can only be run on Linux.

== ARMv8

In this repository we will document only points where ARMv8 differs from ARMv7 behaviour: so you should likely learn ARMv7 first.

ARMv8 is the 64 bit version of the ARM architecture.

It has two states:

* AArch32: 32-bit legacy compatibility mode, similar to ARMv7
* AArch64: 64-bit mode, the main mode of operation

Great summary of differences from AArch32: <https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features>

Some random ones, TODO create clean examples of them:

* the stack has to 16-byte aligned. Therefore, the main way to push things to stack is `ldp` and  `stp`, which push two 8 byte registers at a time

=== ARMv8 movk

Fill a 64 bit register with 4 16-bit instructions one at a time.

Example: link:v8/movk.S[]

Bibliography: https://stackoverflow.com/questions/27938768/moving-a-32-bit-constant-in-arm-arch64-register

=== ARMv8 registers

Example: link:v8/regs.S[]

== Theory

. link:how-to-play-with-arm.md[How to play with ARM]
. link:introduction.md[Introduction]
. link:versions.md[Versions]
. link:calling-conventions.md[Calling conventions]
. link:extensions.md[Extensions]
.. link:thumb.md[Thumb]
. link:vs-x86.md[Vs x86]
. link:compilers.md[Compilers]
. link:free-implementations.md[Free implementations]
. link:gas.md[GAS]
. link:flags.md[Flags]
. link:system-programming.md[System programming]
. link:isa-documentation.md[ISA documentation]
. link:glossary.md[Glossary]

== Bibliography

ISA quick references can be found in some places however:

- <https://web.archive.org/web/20161009122630/http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf>

Getting started tutorials:

* http://www.davespace.co.uk/arm/introduction-to-arm/
* https://azeria-labs.com/writing-arm-assembly-part-1/

=== Official manuals

The official manuals were stored in http://infocenter.arm.com but as of 2017 they started to slowly move to link:https://developer.arm.com[].

Each revision of a document has a "ARM DDI" unique document identifier.

The "ARM Architecture Reference Manuals" are the official canonical ISA documentation document. In this repository, we always reference the following revisions:

Bibliography: https://www.quora.com/Where-can-I-find-the-official-documentation-of-ARM-instruction-set-architectures-ISAs

[[armarm7]]
==== ARMv7 architecture reference manual

ARMv7: https://developer.arm.com/products/architecture/a-profile/docs/ddi0406/latest/arm-architecture-reference-manual-armv7-a-and-armv7-r-edition

We use: DDI 0406C.d: https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf?_ga=2.64816815.1086219598.1531250756-677810532.1526807026

[[armarm8]]
==== ARMv8 architecture reference manual

https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile

We use: ARM DDI 0487C.a: https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf

==== Programmer’s Guide for ARMv8-A

https://developer.arm.com/docs/den0024/latest/preface

A more terse human readable introduction to the ARM architecture than the reference manuals.

We use: DEN0024A https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf
